#-------------------------------------------------------------------------------
# Name:        modulo1
# Purpose:
#
# Author:      tasora
#
# Created:     14/02/2012
# Copyright:   (c) tasora 2012
# Licence:     <your licence>
#-------------------------------------------------------------------------------
#!/usr/bin/env python

def main():
    pass

if __name__ == '__main__':
    main()


import os
import math
import time
import sys, getopt, imp
import ChronoEngine_PYTHON_core as chrono
import ChronoEngine_PYTHON_postprocess as postprocess

m_timestep = 0.01
m_length = 1.0

# ---------------------------------------------------------------------
#
#  load the file generated by the SolidWorks CAD plugin
#  and add it to the ChSystem.
#


print ("Loading C::E scene...");

exported_items = chrono.ImportSolidWorksSystem('engine4c')

print ("...loading done!");


# Print exported items
for my_item in exported_items:
    print (my_item.GetName())

# Add items to the physical system
my_system = chrono.ChSystem()
for my_item in exported_items:
    my_system.Add(my_item)


# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#  SOME MODIFICATIONS....

# ***TRICK***
# Fetch a ChMarker from its name (it is a 'Coordinate system' in
#  the SolidWorks interface)

my_marker = my_system.SearchMarker('Marker_shaft')
if my_marker.IsNull() :
    sys.exit('Error: cannot find marker from its name in the C::E system!')

# ***TRICK***
# Fetch two ChBodyAuxRef objects (the ground, the shaft) from
# their names. Names are as they are named in SolidWorks - see also the dump of
# my_system object with my_system.ShowHierarchy(chrono.GetLog()) if needed)
#   Note.. here we must upcast because Search() returns generic shared
# pointer to a base class ChPhysicsItem, so we use CastToXXYYZZ()

my_item = my_system.Search('Crankshaft-1')
my_shaft  = chrono.CastToChBodyAuxRefShared(my_item)
if my_shaft.IsNull() :
    sys.exit('Error: cannot find shaft  from its name in the C::E system!')

my_item = my_system.Search('ground')
my_ground = chrono.CastToChBodyAuxRefShared(my_item)
if my_ground.IsNull() :
    sys.exit('Error: cannot find ground from its name in the C::E system!')

# ***TRICK***
# Create an engine along the Z direction of the coordsystem specified by
# the marker, and acting between shaft and ground

revolute_csys = my_marker.GetAbsCoord()
link_motor = chrono.ChLinkEngineShared()
link_motor.Initialize(my_shaft, my_ground, revolute_csys)
link_motor.Set_shaft_mode(chrono.ChLinkEngine.ENG_SHAFT_PRISM)
link_motor.Set_eng_mode(chrono.ChLinkEngine.ENG_MODE_SPEED)
link_motor.Get_spe_funct().Set_yconst(2.5*chrono.CH_C_2PI)  # 0.5 Hz to rad/s
my_system.Add(link_motor)

my_shaft.SetWvel_par(chrono.ChVectorD(2,2,2))

# ***TRICK***
# Add a POVray steel material to the shaft for enhanced photorealism
# Thank to the 'assets' system, it is possible to add custom POV statements
# to the the visualization shapes.

if (True):
    shaft_povmat = postprocess.ChPovRayAssetCustomShared()
    shaft_povmat.SetCommands('''
       pigment { color rgbt <0.5,0.5,0.52,0> }
       finish  {    reflection {0.35}
                    ambient 0
                    diffuse 1
                    phong 0.9
                    phong_size 60
                    metallic } ''')
    my_shaft.GetAssets().push_back(shaft_povmat)



#  END OF MODIFICATIONS....
# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^




# ---------------------------------------------------------------------
#
#  Render a short animation by generating scripts
#  to be used with POV-Ray
#

pov_exporter = postprocess.ChPovRay(my_system)

 # Sets some file names for in-out processes.
pov_exporter.SetTemplateFile        ("_template_POV.pov")
pov_exporter.SetOutputScriptFile    ("rendering_frames.pov")
if not os.path.exists("output"):
    os.mkdir("output")
if not os.path.exists("anim"):
    os.mkdir("anim")
pov_exporter.SetOutputDataFilebase("output/my_state")
pov_exporter.SetPictureFilebase("anim/picture")

 # Sets the viewpoint, aimed point, lens angle
pov_exporter.SetCamera(chrono.ChVectorD(0.4,0.6,0.9), chrono.ChVectorD(0.2,0,0), 30)

 # Sets the default ambient light and default light lamp
pov_exporter.SetAmbientLight(chrono.ChColor(1,1,1))
pov_exporter.SetLight(chrono.ChVectorD(-2,2,-1), chrono.ChColor(1.1,1.2,1.2), 1)

 # Sets other settings
pov_exporter.SetPictureSize(640,480)
pov_exporter.SetAmbientLight(chrono.ChColor(2,2,2))

 # Turn on the rendering of xyz axes for the centers of gravity or reference frames:
#pov_exporter.SetShowCOGs  (1, 0.05)
#pov_exporter.SetShowFrames(1, 0.02)
#pov_exporter.SetShowLinks(1, 0.03)
if (False) :
    pov_exporter.SetShowContacts(1,
                            postprocess.ChPovRay.SYMBOL_VECTOR_SCALELENGTH,
                            0.2,    # scale
                            0.0007, # width
                            0.1,    # max size
                            1,0,0.5 ) # colormap on, blue at 0, red at 0.5

# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#  SOME MODIFICATION....

# ***TRICK***
# Add an horizontal grid and a gray plane; also add a light source.
# Use the SetCustomPOVcommandsScript() statement to add POV commands
# to the POV script generated by Chrono::Engine.

pov_exporter.SetCustomPOVcommandsScript(
'''
light_source{ <1,3,1.5> color rgb<1.1,1.1,1.1> }
object{ Grid(0.1,0.04, rgb<0.5,0.5,0.5>, rgbt<1,1,1,1>) translate -0.3*y }
plane{<0,1,0>, 0 pigment{color rgb<0.8,0.8,0.8>} translate -0.301*y }
''')

# ***TRICK***
# Add a camera that moves together with one of the connecting rods;
# note that position and aimpoint are set in conrod coordinate
# system.

if (False):
    my_item = my_system.Search('piston_rod-2/ConRod-1')
    my_rod  = chrono.CastToChBodyAuxRefShared(my_item)
    if my_rod.IsNull() :
        sys.exit('Error: cannot find conrod from its name in the C::E system!')

    my_movingcamera = chrono.ChCameraShared()
    my_movingcamera.SetPosition(chrono.ChVectorD(0,-0.1,-0.700))
    my_movingcamera.SetAimPoint(chrono.ChVectorD(0,-0.1,0))
    #my_movingcamera.SetOrthographic(True)
    my_rod.GetAssets().push_back(my_movingcamera)


# ***TRICK***
# Show reference frames of constraints as small RGB small coordinate systems.
# Also make all bodies semi transparent in POVray raytracing, so that
# you can see better where the constraint coordinate sytstems are.

if (False):
    pov_exporter.SetShowLinks(1, 0.03)
    #pov_exporter.SetShowCOGs  (1, 0.05)
    #pov_exporter.SetShowFrames  (1, 0.05)

    transp_povmat = postprocess.ChPovRayAssetCustomShared()
    transp_povmat.SetCommands('''
       pigment { color rgbt <1,1,1,0.8> }
        ''')

    for aitem in chrono.IterOtherPhysicsItems(my_system):
        aitem.GetAssets().push_back(transp_povmat)


#  END OF MODIFICATIONS....
# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



 # Tell which physical items you want to render
pov_exporter.AddAll()


 # Create the two .pov and .ini files for POV-Ray (this must be done
 # only once at the beginning of the simulation).
pov_exporter.ExportScript()


 # Optionally set some solver parameters.
my_system.SetLcpSolverType(chrono.ChSystem.LCP_ITERATIVE_BARZILAIBORWEIN)
my_system.SetIterLCPmaxItersSpeed(100)
my_system.SetMaxPenetrationRecoverySpeed(.1)
my_system.Set_G_acc(chrono.ChVectorD(0,-9.8,0))

 # Perform a short simulation
nstep =0
while (my_system.GetChTime() < m_length) :

    my_system.DoStepDynamics(m_timestep)

    #if math.fmod(nstep,10) ==0 :
    print ('time=', my_system.GetChTime() )

        # Create the incremental nnnn.dat and nnnn.pov files that will be load
        # by the pov .ini script in POV-Ray (do this at each simulation timestep)
    pov_exporter.ExportData()

    nstep = nstep +1

print ("\n\nOk, Simulation done!");
time.sleep(2)



